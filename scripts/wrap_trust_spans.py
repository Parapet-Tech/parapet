"""
Wrap existing opensource eval cases as trust-span eval cases.

Takes single-content l3_inbound cases and embeds them as untrusted spans
inside trusted tool results from `internal_lookup`. This tests whether
pass 3 (per-span scanning) catches the same attacks that pass 1 catches
when the attack content arrives through the trust-span pathway.

Usage:
    python scripts/wrap_trust_spans.py

Outputs to schema/eval/l3_inbound_trust_wrapped_*.yaml
"""
import yaml
import os
import sys

EVAL_DIR = os.path.join(os.path.dirname(__file__), "..", "schema", "eval")
PREFIX = "Retrieved: "  # 11 chars, consistent offset for all cases
MAX_CONTENT_LEN = 490   # Leave margin below max_length=500 in eval_config


def is_ascii_safe(s):
    """Content must not require JSON escaping beyond identity.

    The eval harness asserts that JSON-escaped content has the same byte
    length as the original. This rules out: quotes, backslashes, control
    chars (< 0x20), DEL (0x7F), and anything non-ASCII (> 0x7E).
    """
    for ch in s:
        code = ord(ch)
        if code < 32 or code > 126:
            return False
        if ch == '"' or ch == '\\':
            return False
    return True


def wrap_case(original, source_name):
    """Wrap a single-content eval case into a trust-span multi-message case."""
    content = original["content"]
    wrapped_content = PREFIX + content

    return {
        "id": f"l3i-trust-wrap-{original['id']}",
        "layer": "l3_inbound",
        "label": original["label"],
        "description": f"Wrapped {source_name}/{original['id']}",
        "messages": [
            {"role": "user", "content": "Look up the document"},
            {
                "role": "tool",
                "name": "internal_lookup",
                "tool_call_id": f"call_wrap_{original['id'].replace('-', '_')}",
                "content": wrapped_content,
                "trust_spans": [
                    {
                        "start": len(PREFIX),
                        "end": len(PREFIX) + len(content),
                        "source": "rag",
                    }
                ],
            },
        ],
    }


def process_source(filename):
    """Process one opensource dataset file, return wrapped cases."""
    path = os.path.join(EVAL_DIR, filename)
    with open(path, encoding="utf-8") as f:
        cases = yaml.safe_load(f)

    source_name = filename.replace(".yaml", "")
    wrapped = []
    skipped_ascii = 0
    skipped_length = 0

    for case in cases:
        if case.get("layer") != "l3_inbound":
            continue

        content = case.get("content", "")
        if not is_ascii_safe(content):
            skipped_ascii += 1
            continue
        if len(content) > MAX_CONTENT_LEN:
            skipped_length += 1
            continue

        wrapped.append(wrap_case(case, source_name))

    return wrapped, skipped_ascii, skipped_length


# Sources to wrap: only l3_inbound cases from opensource datasets.
# Giskard has 0 eligible cases (all non-ASCII), skip it.
SOURCES = {
    "opensource_deepset_attacks.yaml": "attacks",
    "opensource_deepset_benign.yaml": "benign",
    "opensource_gandalf_attacks.yaml": "attacks",
    "opensource_jbb_attacks.yaml": "attacks",
    "opensource_jbb_benign.yaml": "benign",
    "opensource_mosscap_attacks.yaml": "attacks",
}


def main():
    attacks = []
    benign = []
    total_skipped_ascii = 0
    total_skipped_length = 0

    for filename, kind in SOURCES.items():
        wrapped, skip_a, skip_l = process_source(filename)
        total_skipped_ascii += skip_a
        total_skipped_length += skip_l

        if kind == "attacks":
            attacks.extend(wrapped)
        else:
            benign.extend(wrapped)

        print(f"  {filename}: {len(wrapped)} wrapped, {skip_a} skipped (ascii), {skip_l} skipped (length)")

    # Write output files
    attacks_path = os.path.join(EVAL_DIR, "l3_inbound_trust_wrapped_attacks.yaml")
    benign_path = os.path.join(EVAL_DIR, "l3_inbound_trust_wrapped_benign.yaml")

    header_attacks = (
        "# L3-inbound trust-span wrapped attack cases.\n"
        "#\n"
        "# Auto-generated by scripts/wrap_trust_spans.py\n"
        "# Wraps opensource benchmark attacks as untrusted spans inside\n"
        "# trusted tool results from internal_lookup.\n"
        "#\n"
        f"# {len(attacks)} cases from: deepset, gandalf, jbb, mosscap\n\n"
    )
    header_benign = (
        "# L3-inbound trust-span wrapped benign cases.\n"
        "#\n"
        "# Auto-generated by scripts/wrap_trust_spans.py\n"
        "# Wraps opensource benchmark benign content as untrusted spans inside\n"
        "# trusted tool results from internal_lookup.\n"
        "#\n"
        f"# {len(benign)} cases from: deepset, jbb\n\n"
    )

    with open(attacks_path, "w", encoding="utf-8") as f:
        f.write(header_attacks)
        yaml.dump(attacks, f, default_flow_style=False, allow_unicode=False, sort_keys=False, width=1000)

    with open(benign_path, "w", encoding="utf-8") as f:
        f.write(header_benign)
        yaml.dump(benign, f, default_flow_style=False, allow_unicode=False, sort_keys=False, width=1000)

    print(f"\nOutput:")
    print(f"  {attacks_path}: {len(attacks)} attack cases")
    print(f"  {benign_path}: {len(benign)} benign cases")
    print(f"  Skipped: {total_skipped_ascii} (non-ASCII), {total_skipped_length} (too long)")


if __name__ == "__main__":
    main()
